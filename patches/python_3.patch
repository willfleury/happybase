
...which behaves differently on Python 3.
---
 happybase/table.py | 8 +++-----
 1 file changed, 3 insertions(+), 5 deletions(-)

diff --git a/happybase/table.py b/happybase/table.py
index c0f2752..d4f490a 100644
--- a/happybase/table.py
+++ b/happybase/table.py
@@ -77,7 +77,7 @@ def regions(self):
         :rtype: list of dicts
         """
         regions = self.connection.client.getTableRegions(self.name)
-        return map(thrift_type_to_dict, regions)
+        return [thrift_type_to_dict(r) for r in regions]

     #
     # Data retrieval
@@ -210,10 +210,8 @@ def cells(self, row, column, versions=None, timestamp=None,
             cells = self.connection.client.getVerTs(
                 self.name, row, column, timestamp, versions, {})

-        if include_timestamp:
-            return map(make_cell_timestamp, cells)
-        else:
-            return map(make_cell, cells)
+        f = make_cell_timestamp if include_timestamp else make_cell
+        return [f(c) for c in cells]

     def scan(self, row_start=None, row_stop=None, row_prefix=None,
              columns=None, filter=None, timestamp=None,

From f61a5ec420c1c4cad250bddc180a63bc87bfcb38 Mon Sep 17 00:00:00 2001
From: Wouter Bolsterlee <uws@xs4all.nl>
Date: Sun, 20 Mar 2016 22:51:28 +0100
Subject: [PATCH 08/19] Add ensure_bytes() helper

...to coerce unicode text into UTF-8 encoded byte strings.
---
 happybase/util.py | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/happybase/util.py b/happybase/util.py
index 99141f3..c697f90 100644
--- a/happybase/util.py
+++ b/happybase/util.py
@@ -6,6 +6,7 @@

 import re

+import six
 from six.moves import range

 CAPITALS = re.compile('([A-Z])')
@@ -56,6 +57,18 @@ def thrift_type_to_dict(obj):
                 for attr in thrift_attrs(obj))


+def ensure_bytes(str_or_bytes, binary_type=six.binary_type,
+                 text_type=six.text_type):
+    """Convert text into bytes, and leaves bytes as-is."""
+    if isinstance(str_or_bytes, binary_type):
+        return str_or_bytes
+    if isinstance(str_or_bytes, text_type):
+        return str_or_bytes.encode('utf-8')
+    raise TypeError(
+        "input must be a text or byte string, got {}"
+        .format(type(str_or_bytes).__name__))
+
+
 def str_increment(s):
     """Increment and truncate a byte string (for sorting purposes)


From 43f93ae7ae810294e309d6f895830fb990879186 Mon Sep 17 00:00:00 2001
From: Wouter Bolsterlee <uws@xs4all.nl>
Date: Sun, 27 Mar 2016 21:22:25 +0200
Subject: [PATCH 09/19] Clean up helpers to transform rows and cell values

---
 happybase/table.py | 27 ++++++++++++++++-----------
 1 file changed, 16 insertions(+), 11 deletions(-)

diff --git a/happybase/table.py b/happybase/table.py
index d4f490a..75c30ed 100644
--- a/happybase/table.py
+++ b/happybase/table.py
@@ -4,7 +4,6 @@

 import logging
 from numbers import Integral
-from operator import attrgetter
 from struct import Struct

 from six import iteritems
@@ -16,23 +15,27 @@

 logger = logging.getLogger(__name__)

-make_cell = attrgetter('value')
-make_cell_timestamp = attrgetter('value', 'timestamp')
 pack_i64 = Struct('>q').pack


 def make_row(cell_map, include_timestamp):
     """Make a row dict for a cell mapping like ttypes.TRowResult.columns."""
-    cellfn = include_timestamp and make_cell_timestamp or make_cell
-    return dict((cn, cellfn(cell)) for cn, cell in iteritems(cell_map))
+    return {
+        name: (cell.value, cell.timestamp) if include_timestamp else cell.value
+        for name, cell in iteritems(cell_map)
+    }


 def make_ordered_row(sorted_columns, include_timestamp):
     """Make a row dict for sorted column results from scans."""
-    cellfn = include_timestamp and make_cell_timestamp or make_cell
-    return OrderedDict(
-        (column.columnName, cellfn(column.cell))
-        for column in sorted_columns)
+    od = OrderedDict()
+    for column in sorted_columns:
+        if include_timestamp:
+            value = (column.cell.value, column.cell.timestamp)
+        else:
+            value = column.cell.value
+        od[column.columnName] = value
+    return od


 class Table(object):
@@ -210,8 +213,10 @@ def cells(self, row, column, versions=None, timestamp=None,
             cells = self.connection.client.getVerTs(
                 self.name, row, column, timestamp, versions, {})

-        f = make_cell_timestamp if include_timestamp else make_cell
-        return [f(c) for c in cells]
+        return [
+            (c.value, c.timestamp) if include_timestamp else c.value
+            for c in cells
+        ]

     def scan(self, row_start=None, row_stop=None, row_prefix=None,
              columns=None, filter=None, timestamp=None,

From 5cdd102b78d696d123abae4424c1a63f5885e395 Mon Sep 17 00:00:00 2001
From: Wouter Bolsterlee <uws@xs4all.nl>
Date: Mon, 28 Mar 2016 19:30:24 +0200
Subject: [PATCH 10/19] Column families are byte strings

...hence require splitting using a byte string.
---
 happybase/table.py | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/happybase/table.py b/happybase/table.py
index 75c30ed..63425f6 100644
--- a/happybase/table.py
+++ b/happybase/table.py
@@ -64,14 +64,14 @@ def families(self):
         descriptors = self.connection.client.getColumnDescriptors(self.name)
         families = dict()
         for name, descriptor in descriptors.items():
-            name = name.rstrip(':')
+            name = name.rstrip(b':')
             families[name] = thrift_type_to_dict(descriptor)
         return families

     def _column_family_names(self):
         """Retrieve the column family names for this table (internal use)"""
         names = self.connection.client.getColumnDescriptors(self.name).keys()
-        return [name.rstrip(':') for name in names]
+        return [name.rstrip(b':') for name in names]

     def regions(self):
         """Retrieve the regions for this table.

From 76ed812f5f8efa90dd41d51de7952f4f15891ff2 Mon Sep 17 00:00:00 2001
From: Wouter Bolsterlee <uws@xs4all.nl>
Date: Mon, 28 Mar 2016 19:52:08 +0200
Subject: [PATCH 11/19] Rewrite str_increment() as bytes_increment()

...and make it work on both Python 3 and 2.
---
 happybase/table.py |  4 ++--
 happybase/util.py  | 12 +++++++-----
 tests/test_util.py | 28 +++++++++++++++-------------
 3 files changed, 24 insertions(+), 20 deletions(-)

diff --git a/happybase/table.py b/happybase/table.py
index 63425f6..8866109 100644
--- a/happybase/table.py
+++ b/happybase/table.py
@@ -10,7 +10,7 @@

 from .Hbase_thrift import TScan

-from .util import thrift_type_to_dict, str_increment, OrderedDict
+from .util import thrift_type_to_dict, bytes_increment, OrderedDict
 from .batch import Batch

 logger = logging.getLogger(__name__)
@@ -317,7 +317,7 @@ def scan(self, row_start=None, row_stop=None, row_prefix=None,
                     "or 'row_stop'")

             row_start = row_prefix
-            row_stop = str_increment(row_prefix)
+            row_stop = bytes_increment(row_prefix)

         if row_start is None:
             row_start = ''
diff --git a/happybase/util.py b/happybase/util.py
index c697f90..f975464 100644
--- a/happybase/util.py
+++ b/happybase/util.py
@@ -69,7 +69,7 @@ def ensure_bytes(str_or_bytes, binary_type=six.binary_type,
         .format(type(str_or_bytes).__name__))


-def str_increment(s):
+def bytes_increment(b):
     """Increment and truncate a byte string (for sorting purposes)

     This functions returns the shortest string that sorts after the given
@@ -79,8 +79,10 @@ def str_increment(s):
     drops everything after it. If the string only contains ``0xFF`` bytes,
     `None` is returned.
     """
-    for i in range(len(s) - 1, -1, -1):
-        if s[i] != '\xff':
-            return s[:i] + chr(ord(s[i]) + 1)
-
+    assert isinstance(b, six.binary_type)
+    b = bytearray(b)  # Used subset of its API is the same on Python 2 and 3.
+    for i in range(len(b) - 1, -1, -1):
+        if b[i] != 0xff:
+            b[i] += 1
+            return bytes(b[:i+1])
     return None
diff --git a/tests/test_util.py b/tests/test_util.py
index 7eb63d5..ab4a1af 100644
--- a/tests/test_util.py
+++ b/tests/test_util.py
@@ -2,6 +2,8 @@
 HappyBase utility tests.
 """

+from codecs import decode, encode
+
 from nose.tools import assert_equal, assert_less

 import happybase.util as util
@@ -29,26 +31,26 @@ def check(lower_cc, upper_cc, correct):
         yield check, a, b, c


-def test_str_increment():
+def test_bytes_increment():
     def check(s_hex, expected):
-        s = s_hex.decode('hex')
-        v = util.str_increment(s)
-        v_hex = v.encode('hex')
+        s = decode(s_hex, 'hex')
+        v = util.bytes_increment(s)
+        v_hex = encode(v, 'hex')
         assert_equal(expected, v_hex)
         assert_less(s, v)

     test_values = [
-        ('00', '01'),
-        ('01', '02'),
-        ('fe', 'ff'),
-        ('1234', '1235'),
-        ('12fe', '12ff'),
-        ('12ff', '13'),
-        ('424242ff', '424243'),
-        ('4242ffff', '4243'),
+        (b'00', b'01'),
+        (b'01', b'02'),
+        (b'fe', b'ff'),
+        (b'1234', b'1235'),
+        (b'12fe', b'12ff'),
+        (b'12ff', b'13'),
+        (b'424242ff', b'424243'),
+        (b'4242ffff', b'4243'),
     ]

-    assert util.str_increment('\xff\xff\xff') is None
+    assert util.bytes_increment(b'\xff\xff\xff') is None

     for s, expected in test_values:
         yield check, s, expected

From c788d830b1a9e1ad777fd97b59d990fbc4c0285d Mon Sep 17 00:00:00 2001
From: Wouter Bolsterlee <uws@xs4all.nl>
Date: Mon, 28 Mar 2016 20:13:42 +0200
Subject: [PATCH 12/19] Allow table names to be specified as binary or text

In HBase, the name is a byte string, but transparently encoding text
using UTF-8 allows for cleaner code on the Python side. This makes code
like

  connection.table("sometable")

work on both Python 3 and 2.
---
 happybase/connection.py | 17 ++++++++++-------
 1 file changed, 10 insertions(+), 7 deletions(-)

diff --git a/happybase/connection.py b/happybase/connection.py
index 208c599..1dad7d6 100644
--- a/happybase/connection.py
+++ b/happybase/connection.py
@@ -13,7 +13,7 @@

 from .Hbase_thrift import Hbase, ColumnDescriptor
 from .table import Table
-from .util import pep8_to_camel_case
+from .util import ensure_bytes, pep8_to_camel_case

 logger = logging.getLogger(__name__)

@@ -106,19 +106,21 @@ class Connection(object):
     """
     def __init__(self, host=DEFAULT_HOST, port=DEFAULT_PORT, timeout=None,
                  autoconnect=True, table_prefix=None,
-                 table_prefix_separator='_', compat=DEFAULT_COMPAT,
+                 table_prefix_separator=b'_', compat=DEFAULT_COMPAT,
                  transport=DEFAULT_TRANSPORT, protocol=DEFAULT_PROTOCOL):

         if transport not in THRIFT_TRANSPORTS:
             raise ValueError("'transport' must be one of %s"
                              % ", ".join(THRIFT_TRANSPORTS.keys()))

-        if table_prefix is not None \
-                and not isinstance(table_prefix, STRING_OR_BINARY):
-            raise TypeError("'table_prefix' must be a string")
+        if table_prefix is not None:
+            if not isinstance(table_prefix, STRING_OR_BINARY):
+                raise TypeError("'table_prefix' must be a string")
+            table_prefix = ensure_bytes(table_prefix)

         if not isinstance(table_prefix_separator, STRING_OR_BINARY):
             raise TypeError("'table_prefix_separator' must be a string")
+        table_prefix_separator = ensure_bytes(table_prefix_separator)

         if compat not in COMPAT_MODES:
             raise ValueError("'compat' must be one of %s"
@@ -158,9 +160,9 @@ def _refresh_thrift_client(self):

     def _table_name(self, name):
         """Construct a table name by optionally adding a table name prefix."""
+        name = ensure_bytes(name)
         if self.table_prefix is None:
             return name
-
         return self.table_prefix + self.table_prefix_separator + name

     def open(self):
@@ -220,6 +222,7 @@ def table(self, name, use_prefix=True):
         :return: Table instance
         :rtype: :py:class:`Table`
         """
+        name = ensure_bytes(name)
         if use_prefix:
             name = self._table_name(name)
         return Table(name, self)
@@ -241,7 +244,7 @@ def tables(self):

         # Filter using prefix, and strip prefix from names
         if self.table_prefix is not None:
-            prefix = self._table_name('')
+            prefix = self._table_name(b'')
             offset = len(prefix)
             names = [n[offset:] for n in names if n.startswith(prefix)]


From 0903fe261a6371830cffc66e61c9f08f500df6d0 Mon Sep 17 00:00:00 2001
From: Wouter Bolsterlee <uws@xs4all.nl>
Date: Sat, 2 Apr 2016 23:24:51 +0200
Subject: [PATCH 13/19] Update tests for Python 3 compatibility

---
 tests/test_api.py | 248 +++++++++++++++++++++++++++---------------------------
 1 file changed, 123 insertions(+), 125 deletions(-)

diff --git a/tests/test_api.py b/tests/test_api.py
index cbfdbd0..be08e43 100644
--- a/tests/test_api.py
+++ b/tests/test_api.py
@@ -7,6 +7,9 @@
 import random
 import threading

+import six
+from six.moves import range
+
 from nose.tools import (
     assert_dict_equal,
     assert_equal,
@@ -28,8 +31,8 @@
 HAPPYBASE_TRANSPORT = os.environ.get('HAPPYBASE_TRANSPORT', 'buffered')
 KEEP_TABLE = ('HAPPYBASE_NO_CLEANUP' in os.environ)

-TABLE_PREFIX = 'happybase_tests_tmp'
-TEST_TABLE_NAME = 'test1'
+TABLE_PREFIX = b'happybase_tests_tmp'
+TEST_TABLE_NAME = b'test1'

 connection_kwargs = dict(
     host=HAPPYBASE_HOST,
@@ -49,7 +52,7 @@ def maybe_delete_table():
         return

     if TEST_TABLE_NAME in connection.tables():
-        print "Test table already exists; removing it..."
+        print("Test table already exists; removing it...")
         connection.delete_table(TEST_TABLE_NAME, disable=True)


@@ -102,14 +105,14 @@ def test_compaction():


 def test_prefix():
-    assert_equal(TABLE_PREFIX + '_', connection._table_name(''))
-    assert_equal(TABLE_PREFIX + '_foo', connection._table_name('foo'))
+    assert_equal(TABLE_PREFIX + b'_', connection._table_name(''))
+    assert_equal(TABLE_PREFIX + b'_foo', connection._table_name('foo'))

-    assert_equal(connection.table('foobar').name, TABLE_PREFIX + '_foobar')
-    assert_equal(connection.table('foobar', use_prefix=False).name, 'foobar')
+    assert_equal(connection.table('foobar').name, TABLE_PREFIX + b'_foobar')
+    assert_equal(connection.table('foobar', use_prefix=False).name, b'foobar')

     c = Connection(autoconnect=False)
-    assert_equal('foo', c._table_name('foo'))
+    assert_equal(b'foo', c._table_name('foo'))

     with assert_raises(TypeError):
         Connection(autoconnect=False, table_prefix=123)
@@ -147,21 +150,22 @@ def test_invalid_table_create():

 def test_families():
     families = table.families()
-    for name, fdesc in families.iteritems():
-        assert_is_instance(name, basestring)
+    for name, fdesc in six.iteritems(families):
+        assert_is_instance(name, bytes)
         assert_is_instance(fdesc, dict)
         assert_in('name', fdesc)
+        assert_is_instance(fdesc['name'], six.binary_type)
         assert_in('max_versions', fdesc)


 def test_put():
-    table.put('r1', {'cf1:c1': 'v1', 'cf1:c2': 'v2', 'cf2:c3': 'v3'})
-    table.put('r1', {'cf1:c4': 'v2'}, timestamp=2345678)
-    table.put('r1', {'cf1:c4': 'v2'}, timestamp=1369168852994L)
+    table.put(b'r1', {b'cf1:c1': b'v1', b'cf1:c2': b'v2', b'cf2:c3': b'v3'})
+    table.put(b'r1', {b'cf1:c4': b'v2'}, timestamp=2345678)
+    table.put(b'r1', {b'cf1:c4': b'v2'}, timestamp=1369168852994)


 def test_atomic_counters():
-    row = 'row-with-counter'
+    row = b'row-with-counter'
     column = 'cf1:counter'

     assert_equal(0, table.counter_get(row, column))
@@ -188,17 +192,17 @@ def test_batch():
         table.batch(timestamp='invalid')

     b = table.batch()
-    b.put('row1', {'cf1:col1': 'value1',
-                   'cf1:col2': 'value2'})
-    b.put('row2', {'cf1:col1': 'value1',
-                   'cf1:col2': 'value2',
-                   'cf1:col3': 'value3'})
-    b.delete('row1', ['cf1:col4'])
-    b.delete('another-row')
+    b.put(b'row1', {b'cf1:col1': b'value1',
+                    b'cf1:col2': b'value2'})
+    b.put(b'row2', {b'cf1:col1': b'value1',
+                    b'cf1:col2': b'value2',
+                    b'cf1:col3': b'value3'})
+    b.delete(b'row1', [b'cf1:col4'])
+    b.delete(b'another-row')
     b.send()

     b = table.batch(timestamp=1234567)
-    b.put('row1', {'cf1:col5': 'value5'})
+    b.put(b'row1', {b'cf1:col5': b'value5'})
     b.send()

     with assert_raises(ValueError):
@@ -210,48 +214,48 @@ def test_batch():

 def test_batch_context_managers():
     with table.batch() as b:
-        b.put('row4', {'cf1:col3': 'value3'})
-        b.put('row5', {'cf1:col4': 'value4'})
-        b.put('row', {'cf1:col1': 'value1'})
-        b.delete('row', ['cf1:col4'])
-        b.put('row', {'cf1:col2': 'value2'})
+        b.put(b'row4', {b'cf1:col3': b'value3'})
+        b.put(b'row5', {b'cf1:col4': b'value4'})
+        b.put(b'row', {b'cf1:col1': b'value1'})
+        b.delete(b'row', [b'cf1:col4'])
+        b.put(b'row', {b'cf1:col2': b'value2'})

     with table.batch(timestamp=87654321) as b:
-        b.put('row', {'cf1:c3': 'somevalue',
-                      'cf1:c5': 'anothervalue'})
-        b.delete('row', ['cf1:c3'])
+        b.put(b'row', {b'cf1:c3': b'somevalue',
+                       b'cf1:c5': b'anothervalue'})
+        b.delete(b'row', [b'cf1:c3'])

     with assert_raises(ValueError):
         with table.batch(transaction=True) as b:
-            b.put('fooz', {'cf1:bar': 'baz'})
+            b.put(b'fooz', {b'cf1:bar': b'baz'})
             raise ValueError
-    assert_dict_equal({}, table.row('fooz', ['cf1:bar']))
+    assert_dict_equal({}, table.row(b'fooz', [b'cf1:bar']))

     with assert_raises(ValueError):
         with table.batch(transaction=False) as b:
-            b.put('fooz', {'cf1:bar': 'baz'})
+            b.put(b'fooz', {b'cf1:bar': b'baz'})
             raise ValueError
-    assert_dict_equal({'cf1:bar': 'baz'}, table.row('fooz', ['cf1:bar']))
+    assert_dict_equal({b'cf1:bar': b'baz'}, table.row(b'fooz', [b'cf1:bar']))

     with table.batch(batch_size=5) as b:
-        for i in xrange(10):
-            b.put('row-batch1-%03d' % i, {'cf1:': str(i)})
+        for i in range(10):
+            b.put(b'row-batch1-%03d' % i, {b'cf1:': str(i).encode('ascii')})

     with table.batch(batch_size=20) as b:
-        for i in xrange(95):
-            b.put('row-batch2-%03d' % i, {'cf1:': str(i)})
-    assert_equal(95, len(list(table.scan(row_prefix='row-batch2-'))))
+        for i in range(95):
+            b.put(b'row-batch2-%03d' % i, {b'cf1:': str(i).encode('ascii')})
+    assert_equal(95, len(list(table.scan(row_prefix=b'row-batch2-'))))

     with table.batch(batch_size=20) as b:
-        for i in xrange(95):
-            b.delete('row-batch2-%03d' % i)
-    assert_equal(0, len(list(table.scan(row_prefix='row-batch2-'))))
+        for i in range(95):
+            b.delete(b'row-batch2-%03d' % i)
+    assert_equal(0, len(list(table.scan(row_prefix=b'row-batch2-'))))


 def test_row():
     row = table.row
     put = table.put
-    row_key = 'row-test'
+    row_key = b'row-test'

     with assert_raises(TypeError):
         row(row_key, 123)
@@ -259,42 +263,42 @@ def test_row():
     with assert_raises(TypeError):
         row(row_key, timestamp='invalid')

-    put(row_key, {'cf1:col1': 'v1old'}, timestamp=1234)
-    put(row_key, {'cf1:col1': 'v1new'}, timestamp=3456)
-    put(row_key, {'cf1:col2': 'v2',
-                  'cf2:col1': 'v3'})
-    put(row_key, {'cf2:col2': 'v4'}, timestamp=1234)
+    put(row_key, {b'cf1:col1': b'v1old'}, timestamp=1234)
+    put(row_key, {b'cf1:col1': b'v1new'}, timestamp=3456)
+    put(row_key, {b'cf1:col2': b'v2',
+                  b'cf2:col1': b'v3'})
+    put(row_key, {b'cf2:col2': b'v4'}, timestamp=1234)

-    exp = {'cf1:col1': 'v1new',
-           'cf1:col2': 'v2',
-           'cf2:col1': 'v3',
-           'cf2:col2': 'v4'}
+    exp = {b'cf1:col1': b'v1new',
+           b'cf1:col2': b'v2',
+           b'cf2:col1': b'v3',
+           b'cf2:col2': b'v4'}
     assert_dict_equal(exp, row(row_key))

-    exp = {'cf1:col1': 'v1new',
-           'cf1:col2': 'v2'}
-    assert_dict_equal(exp, row(row_key, ['cf1']))
+    exp = {b'cf1:col1': b'v1new',
+           b'cf1:col2': b'v2'}
+    assert_dict_equal(exp, row(row_key, [b'cf1']))

-    exp = {'cf1:col1': 'v1new',
-           'cf2:col2': 'v4'}
-    assert_dict_equal(exp, row(row_key, ['cf1:col1', 'cf2:col2']))
+    exp = {b'cf1:col1': b'v1new',
+           b'cf2:col2': b'v4'}
+    assert_dict_equal(exp, row(row_key, [b'cf1:col1', b'cf2:col2']))

-    exp = {'cf1:col1': 'v1old',
-           'cf2:col2': 'v4'}
+    exp = {b'cf1:col1': b'v1old',
+           b'cf2:col2': b'v4'}
     assert_dict_equal(exp, row(row_key, timestamp=2345))

     assert_dict_equal({}, row(row_key, timestamp=123))

     res = row(row_key, include_timestamp=True)
     assert_equal(len(res), 4)
-    assert_equal('v1new', res['cf1:col1'][0])
-    assert_is_instance(res['cf1:col1'][1], int)
+    assert_equal(b'v1new', res[b'cf1:col1'][0])
+    assert_is_instance(res[b'cf1:col1'][1], int)


 def test_rows():
-    row_keys = ['rows-row1', 'rows-row2', 'rows-row3']
-    data_old = {'cf1:col1': 'v1old', 'cf1:col2': 'v2old'}
-    data_new = {'cf1:col1': 'v1new', 'cf1:col2': 'v2new'}
+    row_keys = [b'rows-row1', b'rows-row2', b'rows-row3']
+    data_old = {b'cf1:col1': b'v1old', b'cf1:col2': b'v2old'}
+    data_new = {b'cf1:col1': b'v1new', b'cf1:col2': b'v2new'}

     with assert_raises(TypeError):
         table.rows(row_keys, object())
@@ -322,11 +326,11 @@ def test_rows():


 def test_cells():
-    row_key = 'cell-test'
-    col = 'cf1:col1'
+    row_key = b'cell-test'
+    col = b'cf1:col1'

-    table.put(row_key, {col: 'old'}, timestamp=1234)
-    table.put(row_key, {col: 'new'})
+    table.put(row_key, {col: b'old'}, timestamp=1234)
+    table.put(row_key, {col: b'new'})

     with assert_raises(TypeError):
         table.cells(row_key, col, versions='invalid')
@@ -339,16 +343,16 @@ def test_cells():

     results = table.cells(row_key, col, versions=1)
     assert_equal(len(results), 1)
-    assert_equal('new', results[0])
+    assert_equal(b'new', results[0])

     results = table.cells(row_key, col)
     assert_equal(len(results), 2)
-    assert_equal('new', results[0])
-    assert_equal('old', results[1])
+    assert_equal(b'new', results[0])
+    assert_equal(b'old', results[1])

     results = table.cells(row_key, col, timestamp=2345, include_timestamp=True)
     assert_equal(len(results), 1)
-    assert_equal('old', results[0][0])
+    assert_equal(b'old', results[0][0])
     assert_equal(1234, results[0][1])


@@ -356,9 +360,6 @@ def test_scan():
     with assert_raises(TypeError):
         list(table.scan(row_prefix='foobar', row_start='xyz'))

-    with assert_raises(ValueError):
-        list(table.scan(batch_size=None))
-
     if connection.compat == '0.90':
         with assert_raises(NotImplementedError):
             list(table.scan(filter='foo'))
@@ -366,19 +367,16 @@ def test_scan():
     with assert_raises(ValueError):
         list(table.scan(limit=0))

-    with assert_raises(TypeError):
-        list(table.scan(row_start='foobar', row_prefix='foo'))
-
     with table.batch() as b:
         for i in range(2000):
-            b.put('row-scan-a%05d' % i,
-                  {'cf1:col1': 'v1',
-                   'cf1:col2': 'v2',
-                   'cf2:col1': 'v1',
-                   'cf2:col2': 'v2'})
-            b.put('row-scan-b%05d' % i,
-                  {'cf1:col1': 'v1',
-                   'cf1:col2': 'v2'})
+            b.put(b'row-scan-a%05d' % i,
+                  {b'cf1:col1': b'v1',
+                   b'cf1:col2': b'v2',
+                   b'cf2:col1': b'v1',
+                   b'cf2:col2': b'v2'})
+            b.put(b'row-scan-b%05d' % i,
+                  {b'cf1:col1': b'v1',
+                   b'cf1:col2': b'v2'})

     def calc_len(scanner):
         d = collections.deque(maxlen=1)
@@ -387,37 +385,37 @@ def calc_len(scanner):
             return d[0][0]
         return 0

-    scanner = table.scan(row_start='row-scan-a00012',
-                         row_stop='row-scan-a00022')
+    scanner = table.scan(row_start=b'row-scan-a00012',
+                         row_stop=b'row-scan-a00022')
     assert_equal(10, calc_len(scanner))

-    scanner = table.scan(row_start='xyz')
+    scanner = table.scan(row_start=b'xyz')
     assert_equal(0, calc_len(scanner))

-    scanner = table.scan(row_start='xyz', row_stop='zyx')
+    scanner = table.scan(row_start=b'xyz', row_stop=b'zyx')
     assert_equal(0, calc_len(scanner))

-    scanner = table.scan(row_start='row-scan-', row_stop='row-scan-a999',
-                         columns=['cf1:col1', 'cf2:col2'])
+    scanner = table.scan(row_start=b'row-scan-', row_stop=b'row-scan-a999',
+                         columns=[b'cf1:col1', b'cf2:col2'])
     row_key, row = next(scanner)
-    assert_equal(row_key, 'row-scan-a00000')
-    assert_dict_equal(row, {'cf1:col1': 'v1',
-                            'cf2:col2': 'v2'})
+    assert_equal(row_key, b'row-scan-a00000')
+    assert_dict_equal(row, {b'cf1:col1': b'v1',
+                            b'cf2:col2': b'v2'})
     assert_equal(2000 - 1, calc_len(scanner))

-    scanner = table.scan(row_prefix='row-scan-a', batch_size=499, limit=1000)
+    scanner = table.scan(row_prefix=b'row-scan-a', batch_size=499, limit=1000)
     assert_equal(1000, calc_len(scanner))

-    scanner = table.scan(row_prefix='row-scan-b', batch_size=1, limit=10)
+    scanner = table.scan(row_prefix=b'row-scan-b', batch_size=1, limit=10)
     assert_equal(10, calc_len(scanner))

-    scanner = table.scan(row_prefix='row-scan-b', batch_size=5, limit=10)
+    scanner = table.scan(row_prefix=b'row-scan-b', batch_size=5, limit=10)
     assert_equal(10, calc_len(scanner))

     scanner = table.scan(timestamp=123)
     assert_equal(0, calc_len(scanner))

-    scanner = table.scan(row_prefix='row', timestamp=123)
+    scanner = table.scan(row_prefix=b'row', timestamp=123)
     assert_equal(0, calc_len(scanner))

     scanner = table.scan(batch_size=20)
@@ -433,9 +431,9 @@ def test_scan_sorting():
         return  # not supported

     input_row = {}
-    for i in xrange(100):
-        input_row['cf1:col-%03d' % i] = ''
-    input_key = 'row-scan-sorted'
+    for i in range(100):
+        input_row[b'cf1:col-%03d' % i] = b''
+    input_key = b'row-scan-sorted'
     table.put(input_key, input_row)

     scan = table.scan(row_start=input_key, sorted_columns=True)
@@ -443,38 +441,38 @@ def test_scan_sorting():
     assert_equal(key, input_key)
     assert_list_equal(
         sorted(input_row.items()),
-        row.items())
+        list(row.items()))


 def test_scan_filter_and_batch_size():
     # See issue #54 and #56
-    filter = "SingleColumnValueFilter ('cf1', 'qual1', =, 'binary:val1')"
+    filter = b"SingleColumnValueFilter ('cf1', 'qual1', =, 'binary:val1')"
     for k, v in table.scan(filter=filter):
-        print v
+        print(v)


 def test_delete():
-    row_key = 'row-test-delete'
-    data = {'cf1:col1': 'v1',
-            'cf1:col2': 'v2',
-            'cf1:col3': 'v3'}
-    table.put(row_key, {'cf1:col2': 'v2old'}, timestamp=1234)
+    row_key = b'row-test-delete'
+    data = {b'cf1:col1': b'v1',
+            b'cf1:col2': b'v2',
+            b'cf1:col3': b'v3'}
+    table.put(row_key, {b'cf1:col2': b'v2old'}, timestamp=1234)
     table.put(row_key, data)

-    table.delete(row_key, ['cf1:col2'], timestamp=2345)
-    assert_equal(1, len(table.cells(row_key, 'cf1:col2', versions=2)))
+    table.delete(row_key, [b'cf1:col2'], timestamp=2345)
+    assert_equal(1, len(table.cells(row_key, b'cf1:col2', versions=2)))
     assert_dict_equal(data, table.row(row_key))

-    table.delete(row_key, ['cf1:col1'])
+    table.delete(row_key, [b'cf1:col1'])
     res = table.row(row_key)
-    assert_not_in('cf1:col1', res)
-    assert_in('cf1:col2', res)
-    assert_in('cf1:col3', res)
+    assert_not_in(b'cf1:col1', res)
+    assert_in(b'cf1:col2', res)
+    assert_in(b'cf1:col3', res)

     table.delete(row_key, timestamp=12345)
     res = table.row(row_key)
-    assert_in('cf1:col2', res)
-    assert_in('cf1:col3', res)
+    assert_in(b'cf1:col2', res)
+    assert_in(b'cf1:col3', res)

     table.delete(row_key)
     assert_dict_equal({}, table.row(row_key))
@@ -494,7 +492,7 @@ def test_connection_pool():

     def run():
         name = threading.current_thread().name
-        print "Thread %s starting" % name
+        print("Thread %s starting" % name)

         def inner_function():
             # Nested connection requests must return the same connection
@@ -503,11 +501,11 @@ def inner_function():

                 # Fake an exception once in a while
                 if random.random() < .25:
-                    print "Introducing random failure"
+                    print("Introducing random failure")
                     connection.transport.close()
                     raise TException("Fake transport exception")

-        for i in xrange(50):
+        for i in range(50):
             with pool.connection() as connection:
                 connection.tables()

@@ -521,12 +519,12 @@ def inner_function():

                 connection.tables()

-        print "Thread %s done" % name
+        print("Thread %s done" % name)

     N_THREADS = 10

     pool = ConnectionPool(size=3, **connection_kwargs)
-    threads = [threading.Thread(target=run) for i in xrange(N_THREADS)]
+    threads = [threading.Thread(target=run) for i in range(N_THREADS)]

     for t in threads:
         t.start()
@@ -537,7 +535,7 @@ def inner_function():

         # filter out finished threads
         threads = [t for t in threads if t.is_alive()]
-        print "%d threads still alive" % len(threads)
+        print("%d threads still alive" % len(threads))


 def test_pool_exhaustion():

From c470029ba744109d6de843fc3a96a76edbd909b9 Mon Sep 17 00:00:00 2001
From: Wouter Bolsterlee <wouter@bolsterl.ee>
Date: Wed, 27 Jul 2016 19:09:40 +0200
Subject: [PATCH 14/19] Remove Python 3 support from todo list

---
 TODO.rst | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/TODO.rst b/TODO.rst
index 4ecc68c..3178e84 100644
--- a/TODO.rst
+++ b/TODO.rst
@@ -16,9 +16,3 @@ future, depending on time, demand, and technical possibilities.
 * Port HappyBase over to the (still experimental) HBase Thrift2 API when it
   becomes mainstream, and expose more of the underlying features nicely in the
   HappyBase API.
-
-* Python 3 support. This would be trivial for HappyBase, now that the
-  underlying Thrift library is Python 3 compatible. `Track`_ this
-  issue online.
-
-.. _Track: https://github.com/wbolster/happybase/issues/40

From 1716721893648bb8e9a2022f7da142c8cd2018ad Mon Sep 17 00:00:00 2001
From: Wouter Bolsterlee <wouter@bolsterl.ee>
Date: Wed, 27 Jul 2016 19:14:44 +0200
Subject: [PATCH 15/19] Remove execfile() from doc config file

...since Python 3 does not have that function anymore.
---
 doc/conf.py | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/doc/conf.py b/doc/conf.py
index 18c3249..4fead40 100644
--- a/doc/conf.py
+++ b/doc/conf.py
@@ -48,7 +48,11 @@
 # built documents.
 #
 # The short X.Y version.
-execfile(os.path.join(os.path.dirname(__file__), '../happybase/_version.py'))
+version_file = os.path.join(
+    os.path.dirname(__file__),
+    '../happybase/_version.py')
+with open(version_file, 'r') as fp:
+    exec(fp.read())
 version = __version__

 # The full version, including alpha/beta/rc tags.

From ec5178d9b192cd0bc8641c804eeffc463b8db093 Mon Sep 17 00:00:00 2001
From: Wouter Bolsterlee <wouter@bolsterl.ee>
Date: Wed, 27 Jul 2016 19:23:45 +0200
Subject: [PATCH 16/19] Update notes about strings/bytes in documentation

---
 doc/user.rst | 21 +++++++++++++++------
 1 file changed, 15 insertions(+), 6 deletions(-)

diff --git a/doc/user.rst b/doc/user.rst
index 521e991..e2e327f 100644
--- a/doc/user.rst
+++ b/doc/user.rst
@@ -287,12 +287,21 @@ supported scanner options.
 Manipulating data
 =================

-HBase does not have any notion of *data types*; all row keys, column names and
-column values are simply treated as raw byte strings. By design, HappyBase does
-*not* do any automatic string conversion. This means that data must be
-converted to byte strings in your application before you pass it to HappyBase,
-for instance by calling ``str()`` or by employing more advanced string
-serialisation techniques like ``struct.pack()``.
+HBase does not have any notion of *data types*; all row keys, column
+names and column values are simply treated as raw byte strings.
+
+By design, HappyBase does *not* do any automatic string conversion.
+This means that data must be converted to byte strings in your
+application before you pass it to HappyBase, for instance by calling
+``s.encode('utf-8')`` on text strings (which use Unicode), or by
+employing more advanced string serialisation techniques like
+``struct.pack()``. Look for HBase modelling techniques for more
+details about this. Note that the underlying Thrift library used by
+HappyBase does some automatic encoding of text strings into bytes, but
+relying on this "feature" is strongly discouraged, since returned data
+will not be decoded automatically, resulting in asymmetric and hence
+confusing behaviour. Having explicit encode and decode steps in your
+application code is the correct way.

 In HBase, all mutations either store data or mark data for deletion; there is
 no such thing as an in-place `update` or `delete`.  HappyBase provides methods

From eae66a37fa13f8dcbe987df9b10a57ce6b691053 Mon Sep 17 00:00:00 2001
From: Wouter Bolsterlee <wouter@bolsterl.ee>
Date: Thu, 28 Jul 2016 09:43:46 +0200
Subject: [PATCH 17/19] Use byte strings and print() function in example code

---
 doc/index.rst      |  18 ++++----
 doc/user.rst       | 127 +++++++++++++++++++++++++++--------------------------
 happybase/table.py |  17 +++----
 3 files changed, 82 insertions(+), 80 deletions(-)

diff --git a/doc/index.rst b/doc/index.rst
index a7aa16c..705f09f 100644
--- a/doc/index.rst
+++ b/doc/index.rst
@@ -39,19 +39,19 @@ The example below illustrates basic usage of the library. The :doc:`user guide
    connection = happybase.Connection('hostname')
    table = connection.table('table-name')

-   table.put('row-key', {'family:qual1': 'value1',
-                         'family:qual2': 'value2'})
+   table.put(b'row-key', {b'family:qual1': b'value1',
+                          b'family:qual2': b'value2'})

-   row = table.row('row-key')
-   print row['family:qual1']  # prints 'value1'
+   row = table.row(b'row-key')
+   print(row[b'family:qual1'])  # prints 'value1'

-   for key, data in table.rows(['row-key-1', 'row-key-2']):
-       print key, data  # prints row key and data for each row
+   for key, data in table.rows([b'row-key-1', b'row-key-2']):
+       print(key, data)  # prints row key and data for each row

-   for key, data in table.scan(row_prefix='row'):
-       print key, data  # prints 'value1' and 'value2'
+   for key, data in table.scan(row_prefix=b'row'):
+       print(key, data)  # prints 'value1' and 'value2'

-   row = table.delete('row-key')
+   row = table.delete(b'row-key')


 Core documentation
diff --git a/doc/user.rst b/doc/user.rst
index e2e327f..b526072 100644
--- a/doc/user.rst
+++ b/doc/user.rst
@@ -50,7 +50,7 @@ The :py:class:`Connection` class provides the main entry point to interact with
 HBase. For instance, to list the available tables, use
 :py:meth:`Connection.tables`::

-   print connection.tables()
+   print(connection.tables())

 Most other methods on the :py:class:`Connection` class are intended for system
 management tasks like creating, dropping, enabling and disabling tables. See the
@@ -126,8 +126,8 @@ At this point, :py:meth:`Connection.tables` no longer includes tables in other
 ‘namespaces’. HappyBase will only return tables with a ``myproject_`` prefix,
 and will also remove the prefix transparently when returning results, e.g.::

-   print connection.tables()  # Table "myproject_XYZ" in HBase will be
-                              # returned as simply "XYZ"
+   print(connection.tables())  # Table "myproject_XYZ" in HBase will be
+                               # returned as simply "XYZ"

 This also applies to other methods that take table names, such as
 :py:meth:`Connection.table`::
@@ -158,27 +158,27 @@ table in HBase. The most basic one is :py:meth:`Table.row`, which retrieves a
 single row from the table, and returns it as a dictionary mapping columns to
 values::

-   row = table.row('row-key')
-   print row['cf1:col1']   # prints the value of cf1:col1
+   row = table.row(b'row-key')
+   print(row[b'cf1:col1'])   # prints the value of cf1:col1

 The :py:meth:`Table.rows` method works just like :py:meth:`Table.row`, but
 takes multiple row keys and returns those as `(key, data)` tuples::

-   rows = table.rows(['row-key-1', 'row-key-2'])
+   rows = table.rows([b'row-key-1', b'row-key-2'])
    for key, data in rows:
-       print key, data
+       print(key, data)

 If you want the results that :py:meth:`Table.rows` returns as a dictionary or
 ordered dictionary, you will have to do this yourself. This is really easy
 though, since the return value can be passed directly to the dictionary
 constructor. For a normal dictionary, order is lost::

-   rows_as_dict = dict(table.rows(['row-key-1', 'row-key-2']))
+   rows_as_dict = dict(table.rows([b'row-key-1', b'row-key-2']))

 …whereas for a :py:class:`OrderedDict`, order is preserved::

    from collections import OrderedDict
-   rows_as_ordered_dict = OrderedDict(table.rows(['row-key-1', 'row-key-2']))
+   rows_as_ordered_dict = OrderedDict(table.rows([b'row-key-1', b'row-key-2']))


 Making more fine-grained selections
@@ -190,16 +190,16 @@ improved by specifying those columns explicitly to :py:meth:`Table.row` and
 :py:meth:`Table.rows`. The `columns` argument takes a list (or tuple) of column
 names::

-   row = table.row('row-key', columns=['cf1:col1', 'cf1:col2'])
-   print row['cf1:col1']
-   print row['cf1:col2']
+   row = table.row(b'row-key', columns=[b'cf1:col1', b'cf1:col2'])
+   print(row[b'cf1:col1'])
+   print(row[b'cf1:col2'])

 Instead of providing both a column family and a column qualifier, items in the
 `columns` argument may also be just a column family, which means that all
 columns from that column family will be retrieved. For example, to get all
 columns and values in the column family `cf1`, use this::

-   row = table.row('row-key', columns=['cf1'])
+   row = table.row(b'row-key', columns=[b'cf1'])

 In HBase, each cell has a timestamp attached to it. In case you don't want to
 work with the latest version of data stored in HBase, the methods that retrieve
@@ -207,15 +207,15 @@ data from the database, e.g. :py:meth:`Table.row`, all accept a `timestamp`
 argument that specifies that the results should be restricted to values with a
 timestamp up to the specified timestamp::

-   row = table.row('row-key', timestamp=123456789)
+   row = table.row(b'row-key', timestamp=123456789)

 By default, HappyBase does not include timestamps in the results it returns. In
 your application needs access to the timestamps, simply set the
 `include_timestamp` argument to ``True``. Now, each cell in the result will be
 returned as a `(value, timestamp)` tuple instead of just a value::

-   row = table.row('row-key', columns=['cf1:col1'], include_timestamp=True)
-   value, timestamp = row['cf1:col1']
+   row = table.row(b'row-key', columns=[b'cf1:col1'], include_timestamp=True)
+   value, timestamp = row[b'cf1:col1']

 HBase supports storing multiple versions of the same cell. This can be
 configured for each column family. To retrieve all versions of a column for a
@@ -225,13 +225,13 @@ argument specifies the maximum number of versions to return. Just like the
 methods that retrieve rows, the `include_timestamp` argument determines whether
 timestamps are included in the result. Example::

-   values = table.cells('row-key', 'cf1:col1', versions=2)
+   values = table.cells(b'row-key', b'cf1:col1', versions=2)
    for value in values:
-       print "Cell data: %s" % value
+       print("Cell data: {}".format(value))

-   cells = table.cells('row-key', 'cf1:col1', versions=3, include_timestamp=True)
+   cells = table.cells(b'row-key', b'cf1:col1', versions=3, include_timestamp=True)
    for value, timestamp in cells:
-       print "Cell data at %d: %s" % (timestamp, value)
+       print("Cell data at {}: {}".format(timestamp, value))

 Note that the result may contain fewer cells than requested. The cell may just
 have fewer versions, or you may have requested more versions than HBase keeps
@@ -246,32 +246,32 @@ efficiently iterated over using a table scanner, created using
 looks like this::

    for key, data in table.scan():
-       print key, data
+       print(key, data)

 Doing full table scans like in the example above is prohibitively expensive in
 practice. Scans can be restricted in several ways to make more selective range
 queries. One way is to specify start or stop keys, or both. To iterate over all
 rows from row `aaa` to the end of the table::

-   for key, data in table.scan(row_start='aaa'):
-       print key, data
+   for key, data in table.scan(row_start=b'aaa'):
+       print(key, data)

 To iterate over all rows from the start of the table up to row `xyz`, use this::

-   for key, data in table.scan(row_stop='xyz'):
-       print key, data
+   for key, data in table.scan(row_stop=b'xyz'):
+       print(key, data)

 To iterate over all rows between row `aaa` (included) and `xyz` (not included),
 supply both::

-   for key, data in table.scan(row_start='aaa', row_stop='xyz'):
-       print key, data
+   for key, data in table.scan(row_start=b'aaa', row_stop=b'xyz'):
+       print(key, data)

 An alternative is to use a key prefix. For example, to iterate over all rows
 starting with `abc`::

-   for key, data in table.scan(row_prefix='abc'):
-       print key, data
+   for key, data in table.scan(row_prefix=b'abc'):
+       print(key, data)

 The scanner examples above only limit the results by row key using the
 `row_start`, `row_stop`, and `row_prefix` arguments, but scanners can also
@@ -315,12 +315,12 @@ To store a single cell of data in our table, we can use :py:meth:`Table.put`,
 which takes the row key, and the data to store. The data should be a dictionary
 mapping the column name to a value::

-   table.put('row-key', {'cf:col1': 'value1',
-                         'cf:col2': 'value2'})
+   table.put(b'row-key', {b'cf:col1': b'value1',
+                          b'cf:col2': b'value2'})

 Use the `timestamp` argument if you want to provide timestamps explicitly::

-   table.put('row-key', {'cf:col1': 'value1'}, timestamp=123456789)
+   table.put(b'row-key', {b'cf:col1': b'value1'}, timestamp=123456789)

 If omitted, HBase defaults to the current system time.

@@ -330,12 +330,12 @@ Deleting data
 The :py:meth:`Table.delete` method deletes data from a table. To delete a
 complete row, just specify the row key::

-   table.delete('row-key')
+   table.delete(b'row-key')

 To delete one or more columns instead of a complete row, also specify the
 `columns` argument::

-   table.delete('row-key', columns=['cf1:col1', 'cf1:col2'])
+   table.delete(b'row-key', columns=[b'cf1:col1', b'cf1:col2'])

 The optional `timestamp` argument restricts the delete operation to data up to
 the specified timestamp.
@@ -353,10 +353,10 @@ delete methods, just like the :py:class:`Table` class, but the changes are sent
 to the server in a single round-trip using :py:meth:`Batch.send`::

    b = table.batch()
-   b.put('row-key-1', {'cf:col1': 'value1', 'cf:col2': 'value2'})
-   b.put('row-key-2', {'cf:col2': 'value2', 'cf:col3': 'value3'})
-   b.put('row-key-3', {'cf:col3': 'value3', 'cf:col4': 'value4'})
-   b.delete('row-key-4')
+   b.put(b'row-key-1', {b'cf:col1': b'value1', b'cf:col2': b'value2'})
+   b.put(b'row-key-2', {b'cf:col2': b'value2', b'cf:col3': b'value3'})
+   b.put(b'row-key-3', {b'cf:col3': b'value3', b'cf:col4': b'value4'})
+   b.delete(b'row-key-4')
    b.send()

 .. note::
@@ -379,10 +379,10 @@ useful in combination with Python's ``with`` construct. The example above can
 be simplified to read::

    with table.batch() as b:
-       b.put('row-key-1', {'cf:col1': 'value1', 'cf:col2': 'value2'})
-       b.put('row-key-2', {'cf:col2': 'value2', 'cf:col3': 'value3'})
-       b.put('row-key-3', {'cf:col3': 'value3', 'cf:col4': 'value4'})
-       b.delete('row-key-4')
+       b.put(b'row-key-1', {b'cf:col1': b'value1', b'cf:col2': b'value2'})
+       b.put(b'row-key-2', {b'cf:col2': b'value2', b'cf:col3': b'value3'})
+       b.put(b'row-key-3', {b'cf:col3': b'value3', b'cf:col4': b'value4'})
+       b.delete(b'row-key-4')

 As you can see, there is no call to :py:meth:`Batch.send` anymore. The batch is
 automatically applied when the ``with`` code block terminates, even in case of
@@ -393,13 +393,13 @@ manager this would look something like this::

    b = table.batch()
    try:
-       b.put('row-key-1', {'cf:col1': 'value1', 'cf:col2': 'value2'})
-       b.put('row-key-2', {'cf:col2': 'value2', 'cf:col3': 'value3'})
-       b.put('row-key-3', {'cf:col3': 'value3', 'cf:col4': 'value4'})
-       b.delete('row-key-4')
+       b.put(b'row-key-1', {b'cf:col1': b'value1', b'cf:col2': b'value2'})
+       b.put(b'row-key-2', {b'cf:col2': b'value2', b'cf:col3': b'value3'})
+       b.put(b'row-key-3', {b'cf:col3': b'value3', b'cf:col4': b'value4'})
+       b.delete(b'row-key-4')
        raise ValueError("Something went wrong!")
    except ValueError as e:
-       # error handling goes here; nothing is sent to HBase
+       # error handling goes here; nothing will be sent to HBase
        pass
    else:
        # no exceptions; send data
@@ -410,10 +410,10 @@ Obtaining the same behaviour is easier using a ``with`` block. The

    try:
        with table.batch(transaction=True) as b:
-           b.put('row-key-1', {'cf:col1': 'value1', 'cf:col2': 'value2'})
-           b.put('row-key-2', {'cf:col2': 'value2', 'cf:col3': 'value3'})
-           b.put('row-key-3', {'cf:col3': 'value3', 'cf:col4': 'value4'})
-           b.delete('row-key-4')
+           b.put(b'row-key-1', {b'cf:col1': b'value1', b'cf:col2': b'value2'})
+           b.put(b'row-key-2', {b'cf:col2': b'value2', b'cf:col3': b'value3'})
+           b.put(b'row-key-3', {b'cf:col3': b'value3', b'cf:col4': b'value4'})
+           b.delete(b'row-key-4')
            raise ValueError("Something went wrong!")
    except ValueError:
        # error handling goes here; nothing is sent to HBase
@@ -435,8 +435,10 @@ example, this will result in three round-trips to the server (two batches with
    with table.batch(batch_size=1000) as b:
        for i in range(1200):
            # this put() will result in two mutations (two cells)
-           b.put('row-%04d' % i, {'cf1:col1': 'v1',
-                                  'cf1:col2': 'v2',})
+           b.put(b'row-%04d'.format(i), {
+               b'cf1:col1': b'v1',
+               b'cf1:col2': b'v2',
+           })

 The appropriate `batch_size` is very application-specific since it depends on
 the data size, so just experiment to see how different sizes work for your
@@ -451,23 +453,23 @@ interpreted as big-endian 64-bit signed integers by HBase. Counters are
 automatically initialised to 0 upon first use. When incrementing or
 decrementing a counter, the value after modification is returned. Example::

-   print table.counter_inc('row-key', 'cf1:counter')  # prints 1
-   print table.counter_inc('row-key', 'cf1:counter')  # prints 2
-   print table.counter_inc('row-key', 'cf1:counter')  # prints 3
+   print(table.counter_inc(b'row-key', b'cf1:counter'))  # prints 1
+   print(table.counter_inc(b'row-key', b'cf1:counter'))  # prints 2
+   print(table.counter_inc(b'row-key', b'cf1:counter'))  # prints 3

-   print table.counter_dec('row-key', 'cf1:counter')  # prints 2
+   print(table.counter_dec(b'row-key', b'cf1:counter'))  # prints 2

 The optional `value` argument specifies how much to increment or decrement by::

-   print table.counter_inc('row-key', 'cf1:counter', value=3)  # prints 5
+   print(table.counter_inc(b'row-key', b'cf1:counter', value=3))  # prints 5

 While counters are typically used with the increment and decrement functions
 shown above, the :py:meth:`Table.counter_get` and :py:meth:`Table.counter_set`
 methods can be used to retrieve or set a counter value directly::

-   print table.counter_get('row-key', 'cf1:counter')  # prints 5
+   print(table.counter_get(b'row-key', b'cf1:counter'))  # prints 5

-   table.counter_set('row-key', 'cf1:counter', 12)
+   table.counter_set(b'row-key', b'cf1:counter', 12)

 .. note::

@@ -477,7 +479,6 @@ methods can be used to retrieve or set a counter value directly::
    :py:meth:`~Table.counter_dec` instead!


-
 Using the connection pool
 =========================

@@ -514,7 +515,7 @@ are actually returned to the pool after use. Example::
    pool = happybase.ConnectionPool(size=3, host='...')

    with pool.connection() as connection:
-       print connection.tables()
+       print(connection.tables())

 .. warning::

@@ -530,7 +531,7 @@ data outside the ``with`` block::

    with pool.connection() as connection:
        table = connection.table('table-name')
-       row = table.row('row-key')
+       row = table.row(b'row-key')

    process_data(row)

diff --git a/happybase/table.py b/happybase/table.py
index 8866109..4400723 100644
--- a/happybase/table.py
+++ b/happybase/table.py
@@ -93,12 +93,13 @@ def row(self, row, columns=None, timestamp=None, include_timestamp=False):
         argument and returns the columns and values for this row as
         a dictionary.

-        The `row` argument is the row key of the row. If the `columns` argument
-        is specified, only the values for these columns will be returned
-        instead of all available columns. The `columns` argument should be
-        a list or tuple containing strings. Each name can be a column family,
-        such as `cf1` or `cf1:` (the trailing colon is not required), or
-        a column family with a qualifier, such as `cf1:col1`.
+        The `row` argument is the row key of the row. If the `columns`
+        argument is specified, only the values for these columns will be
+        returned instead of all available columns. The `columns`
+        argument should be a list or tuple containing byte strings. Each
+        name can be a column family, such as ``b'cf1'`` or ``b'cf1:'``
+        (the trailing colon is not required), or a column family with a
+        qualifier, such as ``b'cf1:col1'``.

         If specified, the `timestamp` argument specifies the maximum version
         that results may have. The `include_timestamp` argument specifies
@@ -424,8 +425,8 @@ def put(self, row, data, timestamp=None, wal=True):
         This method stores the data in the `data` argument for the row
         specified by `row`. The `data` argument is dictionary that maps columns
         to values. Column names must include a family and qualifier part, e.g.
-        `cf:col`, though the qualifier part may be the empty string, e.g.
-        `cf:`.
+        ``b'cf:col'``, though the qualifier part may be the empty string, e.g.
+        ``b'cf:'``.

         Note that, in many situations, :py:meth:`batch()` is a more appropriate
         method to manipulate data.

From fd0d175b603b61262a674592ce74e457357f574a Mon Sep 17 00:00:00 2001
From: Wouter Bolsterlee <wouter@bolsterl.ee>
Date: Thu, 28 Jul 2016 09:45:29 +0200
Subject: [PATCH 18/19] Mention Python 3 in setup.py trove classifiers

---
 setup.py | 1 +
 1 file changed, 1 insertion(+)

diff --git a/setup.py b/setup.py
index d3acac6..e96b6a5 100644
--- a/setup.py
+++ b/setup.py
@@ -38,6 +38,7 @@ def get_install_requires():
         "Intended Audience :: Developers",
         "License :: OSI Approved :: MIT License",
         "Programming Language :: Python :: 2",
+        "Programming Language :: Python :: 3",
         "Topic :: Database",
         "Topic :: Software Development :: Libraries :: Python Modules",
     )

From fc506cda98c88262be5889fcfd721606be01e53b Mon Sep 17 00:00:00 2001
From: Wouter Bolsterlee <wouter@bolsterl.ee>
Date: Thu, 28 Jul 2016 09:46:31 +0200
Subject: [PATCH 19/19] Fix outdated comment

---
 happybase/util.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/happybase/util.py b/happybase/util.py
index f975464..637003a 100644
--- a/happybase/util.py
+++ b/happybase/util.py
@@ -13,7 +13,7 @@


 try:
-    # Python 2.7
+    # Python 2.7 and up
     from collections import OrderedDict
 except ImportError:
     try: